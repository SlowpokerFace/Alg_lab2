# Лабораторная работа 2


Выполнил:    Шестиперстов Валентин 22ПИ3  
Логин в контесте:    vlshestiperstov@edu.hse.ru  
Язык программирования: Python  
Дополнительные модули: matplotlib, time, bisect
## Задача
Дано `N` прямоугольников на плоскости с углами в целочисленных координатах
 и `M` точек.
 Скольким прямоугольникам принадлежит точка с координатами (x,y)?. 
### Цель работы
выполнить одну и ту же задачу – нахождение количества прямоугольников, которым принадлежит определенная точка, с помощью трех разных алгоритмов и проанализировать полученные результаты
## Ход работы
## Перебор (BruteForce)
Поиск `O(N * M)`, где `M` - количество точек, `N` - количество прямоугольников.
Препроцессинг отсутствует
```Python
  for point in points:
    k = 0
    for rectangle in rectangles:
        if rectangle[0][0] <= point[0] < rectangle[1][0] and rectangle[0][1] <= point[1] < rectangle[1][1]:
            k += 1
```
## Алгоритм на карте со сжатием координат (Map algorithm)
Подготовка `O(N^3)`, поиск `O(M * logN)`, где `M` - количество точек, `N` - количество прямоугольников.
Сожмем все координаты прямоугольников, построим двумерный массив, который и будет хранить сжатые прямоугольники. В таком случае для ответа нужно сжать и передать координату. 
*Препроцессинг:*
```Python
    x_coords = set()
    y_coords = set()
    for rectangle in rectangles:
        x_coords.add(rectangle[0][0])
        x_coords.add(rectangle[1][0])
        y_coords.add(rectangle[0][1])
        y_coords.add(rectangle[1][1])
    x_coords = sorted(list(x_coords))
    y_coords = sorted(list(y_coords))
    x_index = {}
    y_index = {}
    ind = 0
    for i in range(len(x_coords)):
        x_index[x_coords[i]] = ind
        ind += 1
    ind = 0
    for i in range(len(y_coords)):
        y_index[y_coords[i]] = ind
        ind += 1

    map = [[0] * len(y_index) for i in range(len(x_index))]
    for i in rectangles:
        x_max = x_index[i[1][0]]
        y_max = y_index[i[1][1]]
        for x in range(x_index[i[0][0]], x_max):
            for y in range(y_index[i[0][1]], y_max):
                map[x][y] += 1
```
*Ответ на запрос:*
```Python
   x = bisect.bisect_right(x_coords, x) - 1
        y = bisect.bisect_right(y_coords, y) - 1
        a = map[x][y]
```
*Примечание:*  
Из-за особенностей Python и надобности в переборе большого числа значений, данный алгоритм работает даже медленнее, чем bruteforce, начиная с некоторого количества прямоугольников. 
### Алгоритм на персистентном дереве отрезков (Persistent segment tree algorithm) 
Подготовка, `O(N * logN)`, Поиск`O(M * logN)`,  где `M` - количество точек, `N` - количество прямоугольников.
Сожмем координаты прямоугольников. Отсортируем прямоугольники по иксу. Далее пройдемся по всем иксам и будем добавлять в дерево нижнюю и верхнюю границу по `y` и 1, если прямоугольник в соответствующей вершине появился и -1, если закончился. Тогда, чтобы ответить на запрос, нам достаточно сжать координату точки, найти какой версии соответствует сжатая координата х и взять элемент по у в дереве.
Код можно найти в репозитории в файле alg3
### Тестирование
Данные для проведения тестов генерировались по следующим условиям:
- Для тестового набора прямоугольников - набор вложенных друг в друга прмоугольников. имеющих координаты с шагом, равным 2:
`{(10*i, 10*i), (10*(2*N-i), 10*(2*N-i))}`.
- Для тестового набора точек - неслучайный набор координат точек распределенных равномерно по ненулевому пересечению прямоугольников - хэш функции от i с разным базисом для x и y:
`(p*i)^31%(20*N)`, p - большое простое, разное для x и y.
- Количество прямоугольников равно `2 ^ i`, где `0 <= i <= 12`
- Количество точек для каждого из значений `i` равнялось `10000`



### Измерение времени работы алгоритмов
Данные измерений хранятся в файле output_data.txt
![image](https://github.com/SlowpokerFace/Alg_lab2/blob/e171b5868af3ca0af85694f4dacfc504518df947/graph.png)

Из графика видно, что время работы BruteForce-алгоритма квадратично растет и данный алгоритм целезообразно использовать при количестве прямоугольников, меньшем 64 (или 32, в зависимости от требований к скорости).
Map algorithm работает также быстро, как Persistent segment tree algorithm при количестве прямоугольников, меньшем 256, а затем время начинает критически быстро расти. Persistent segment tree algorithm работает с высокой
скоростью при малых и больших (вплоть до 4096) количествах прямоугольников, определенно лучший алгоритм.  
### Вывод:
BruteForce можно испльзовать при количестве при количестве прямоугольников n < 64, Map algorithm при n < 256 и Persistent segment tree algorithm при любых значениях n (из рассмотренных, 1 <=n <= 4096)
